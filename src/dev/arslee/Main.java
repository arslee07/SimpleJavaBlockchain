// Назв. проекта:             Блокчейн-технологии
// Подготовил:                Арсений Лиунша
// Исходный код доступен на:  https://github.com/arslee07/SimpleJavaBlockchain
// Специально для конкурса от https://it-cube28.ru/


// Заменить на свой домен!
package dev.arslee;


import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.ArrayList;


/**

 В этом скрипте мы шаг за шагом будем узнавать, как работают
 современные криптовалюты и блокчейн-технологии, а также попробуем
 создать свою собственную простейшую цифровую валюту.

 Но для начала немного теории.
   Биткойн - децентрализованная платежная система, впервые представленная
 в 2009 году в одноименном документе мистическим Сатоши Накамото,
 личность которого так и не была раскрыта. Все транзакции Биткойна
 записаны в виде единой сберкнижки, копии которого распределены и
 активно синхронизируются между компьютерами по всему миру. В отличие
 от традиционных платежных систем, которые строятся на доверии, сеть
 Биткойна строится на стойкости криптографии.
   В каждой транзакции хранится информация о предыдущей, поэтому подделав
 запись в цепочке, все последующие записи становятся недействительными.
 Для дополнительной защиты на все переводы производится подпись. Для
 создания подписи так называемые "майнеры" участвуют в гонке, кто первый
 решит сложную криптографическую задачу, а заодно и получит за эту подпись
 награду в виде новых сгенерированных монет.

 Окей, с теорией все решено (но не закончено), так что можно приступать!

*/


// Предлагаю начать с класса, содержаще важные утилиты для работы всей программы.
class Utils {
    /**

        Хэширование - фундаментальная часть работы всего блокчейна.
      Простыми словами, хэширование представляет собой преобразование любого
      объема информации в уникальный набор символов, который присущ только
      этому массиву входящей информации. Этот набор символов и будет называться хэшем.
      Например, захэшировав строку "hello world", используя алгоритм sha256, мы получим
      следующее: "b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9".
      Именно этот набор рандомных символов и называется хэшем. Теперь, давайте
      поменяем фразу, пускай это будет, скажем "hello worldd". Теперь хэш равен
      "6df42afe8fafbe77089309b732b5c20234d4b0ed429144ba5b8471b1b3713102".
      Видно невооруженным глазом, что выход абсолютно разный. Это и есть главная
      фишка хэш-функций. Если мы изменим данные, пускай даже незначительно, то
      хэш будет совсем другой. Технически, хэш - это огромное число, записанное
      в шестнадцатеричной системе счисления.
        Однако, (очень, и очень редко в слабозащищенных алгоритмах) возникают ситуации,
      когда при двух разных входах получается один и тот же хэш. Такие ситуации зовутся
      коллизиями. К счастью, в протоколе Биткойн используется алгоритм SHA-256, где максимальное
      число хэш-функции равно 2 в 256 степени. Посчитав степень, мы получим
      115792089237316195423570985008687907853269984665640564039457584007913129639936.
      Согласитесь, довольно крупное число. Так что в данном алгоритме вероятность коллизии
      сводится к теоретическому минимуму.

      Теперь давайте напишем саму функцию.

     */
    public static String sha256(String base) {
        try {
            // Подготовим экземпляр нашей хэш-функции
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            // Преобразуем вход в массив захэшированных байтов
            byte[] hash = digest.digest(base.getBytes(StandardCharsets.UTF_8));
            // Подготовим буфер для будущего вывода
            StringBuilder hexString = new StringBuilder();

            // Добавляем поочередно в строку байты в HEX-формате
            for (byte b : hash) {
                String hex = Integer.toHexString(0xff & b);
                if (hex.length() == 1) hexString.append('0');
                hexString.append(hex);
            }

            // Возвращаем результат
            return hexString.toString();

        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    }
}

/**

 Блок — это основная часть всей цепочки блоков. Практически во всех случаях блоки
 добавляются в конец цепи, которая содержит различные данные. Когда блок добавлен
 в конец цепи, он не может быть изменен, так как если мы изменим данные блока, то
 его хэш-сумма будет совсем другой. А так как хэш этого блока хранится в следующем,
 то хэш следующего блока будет недействительна, так как 'previousHash' левого блока
 не будет равно фактическому хэшу предыдущего, и все последующие блоки также будут
 недействительные.

*/
class Block {
    // Давайте объявим переменные:
    public final long index;          // Индекс (расположение) блока в цепочке
    public final long timestamp;      // Отметка времени в UNIX-формате
    public final BlockData data;      // Данные блока
    public final String previousHash; // Хэш-сумма предыдущего блока
    public String hash;               // Хэш-сумма этого блока

    // Конструктор нашего класса
    public Block(long index, long timestamp, BlockData data, String previousHash) {
        this.index = index;
        this.timestamp = timestamp;
        this.data = data;
        this.previousHash = previousHash;
        this.hash = computeHash();
    }

    // Метод, возвращающий хэш блока
    public String computeHash() {
        hash = Utils.sha256(this.hashData());
        return Utils.sha256(this.hashData());
    }

    // Так как хэш-функция принимает строку, то давайте
    // сделаем для нее вспомогательный метод
    public String hashData() {
        return index + timestamp + data.toString() + previousHash;
    }

    // Метод, красиво выводящий данные на консоль
    public void print() {
        System.out.println("Index: "      + index           +"\n"+
                           "Timestamp: "  + timestamp       +"\n"+
                           "Data: "       + data.toString() +"\n"+
                           "Prev. hash: " + previousHash    +"\n"+
                           "Hash: "       + hash            +"\n");
    }
}

/**

  Небольшой класс, хранящий данные блока.

 */
class BlockData {
    // Объявим переменные:
    public final String from; // Отправитель
    public final String to;   // Получатель
    public final int amount;  // Сумма перевода

    // Nonce - число, перебираемое во время майнинга.
    // Но об мы этом поговорим подробнее позже.
    public int nonce = 0;

    // Конструктор класса
    public BlockData(String from, String to, int amount) {
        this.from = from;
        this.to = to;
        this.amount = amount;
    }

    // Красивый вывод данных
    @Override
    public String toString() {
        return "{ from: '" + from + "', to: '" + to + "', amount: " + amount + ", nonce: " + nonce + " }";
    }
}

/**

 Блокчейн - это база данных, записи которой защищены криптографически.
 Единица цепочки называется блоком. Именно эту технологию придумал и
 описал в документе создатель(-и) Биткойна - Сатоши Накамото в 2008 г.

*/
class Blockchain {
    public ArrayList<Block> chain; // Цепочка блоков

    // Генезис-блок - блок, с которого начинается
    // вся последующая цепочка.
    public static Block getGenesisBlock() {
        // Коли мы можем сюда писать что хотим,
        // так давайте же для эксперимента сделаем
        // транзакцию Bob'у на 1000 у.е., почему нет? :)
        return new Block(0, 0, new BlockData("GENESIS", "bob", 1000), "0");
    }

    // Конструктор класса
    public Blockchain() {
        this.chain = new ArrayList<>();
        // Добавляем генезис блок в начало цепочки
        chain.add(getGenesisBlock());
    }

    // Метод добавления блока в цепочку
    public void addBlock(BlockData data) {
        // Создадим новый блок...
        Block block = new Block(
                chain.size(),
                System.currentTimeMillis(),
                data,
                chain.get(chain.size()-1).hash
        );

        // Подпишем его...
        mine(block);
        // И, наконец, добавим в цепочку!
        chain.add(block);
    }

    /**

       Простыми словами, майнинг - это процесс подписи блоков.
       Для этого подбирается такое число, чтобы при хэшировании
       блока вместе с ним, хэш начинался на определенное кол-во
       нулей. Этот процесс нужен для того, чтобы замедлить
       действия злоумышленника, который пытается подделать блоки,
       так как процесс майнинга достаточно ресурсоемкий, и
       подделывать все подписи цепочки нужно будет невероятно долго.

     */
    public static void mine(Block block) {
        System.out.println("Майним...");

        // Перебираем nonce, пока хэш не будет начинаться на 5 нулей
        while (!block.computeHash().startsWith("00000"))
            // Да, вот так вот просто устроен майнинг :D
            block.data.nonce++;

        System.out.println("Решено! Ответ: " + block.data.nonce);
    }

    // Проверка цепочки на подлинность
    public Boolean valid() {
        // Если хэш прототипа генезис блока не равен хэшу
        // первого блока в цепи, то цепь недействительна.
        if (!getGenesisBlock().hash.equals(chain.get(0).hash))
            return false;


        // Теперь переберем все остальные блоки
        for (int i = 1; i < chain.size(); i++)
            // Если хэш предыдущего блока не равен хэшу
            // последнего, то цепь недействительна.
            if (!chain.get(i-1).computeHash().equals(chain.get(i).previousHash))
                return false;

        // В противном случае, возвращаем true
        return true;
    }

    // Вспомогательный метод, которы вернет
    // баланс пользователя по его имени
    public int getBalanceByName(String name) {
        // Объявим переменную, которая хранит
        // баланс пользователя
        int bal = 0;

        // Перебираем каждый блок и смотрим
        // данные транзакции и прибавляем/вычитаем
        // баланс пользователя
        for (Block block : this.chain) {
            if (block.data.from.equals(name))
                bal -= block.data.amount;

            if (block.data.to.equals(name))
                bal += block.data.amount;

        }

        // Возвращаем баланс
        return bal;
    }

    // Метод, выводящий на экран весь блокчейн
    public void print() {
        System.out.println("\n--------------------\n");
        for (Block block : this.chain) block.print();
        System.out.println("--------------------\n");
    }
}

/**

 Итак, когда мы подготовили все необходимое, давайте
 наконец-таки напишем свой первый блокчейн.

*/
public class Main {
    public static void main(String[] args) {
        // Предлагаю назвать нашу валюту SimpleCoin
        Blockchain SimpleCoin = new Blockchain();

        // Переведем 531 монету со счета Bob на счет Alice
        SimpleCoin.addBlock(new BlockData("bob", "alice", 531));
        // Переведем 125 монет со счета Alice на счет Peter
        SimpleCoin.addBlock(new BlockData("alice", "peter", 125));
        // Переведем 68 монет со счета Peter на счет Bob
        SimpleCoin.addBlock(new BlockData("peter", "bob", 68));


        /*

          Можно поиграться и самостоятельно добавить/убрать строки с переводами.
          Помните, что изначально всегда у Bob'а 1000 монет, т.к. это прописано
          в генезис-блоке

        */


        // Выведем на консоль весь блокчейн
        SimpleCoin.print();

        // Выведем на консоль балансы пользователей
        System.out.println("Баланс Боба: " + SimpleCoin.getBalanceByName("bob"));
        System.out.println("Баланс Алисы: " + SimpleCoin.getBalanceByName("alice"));
        System.out.println("Баланс Питера: " + SimpleCoin.getBalanceByName("peter"));

        // Проверим цепочку на подлинность, мало ли :)
        System.out.println(SimpleCoin.valid() ? "Цепочка валидная!" : "Цепочка невалидная!");
    }
}

/*

  Поздравляю, вы дошли до конца моего проекта.
  Он еще далек до настоящей криптовалюты, так как
  в нем не реализованны узлы (сервера, хранящие блокчейн),
  а также на данный момент доступ к монетам любого кошелька
  имеет каждый, кто захочет. Но камон, же все равно круто
  получилось, не так ли? Надеюсь, что вам понравилось! :D

*/